<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mos6581</title><link href="http://www.mos6581.org/" rel="alternate"></link><link href="http://www.mos6581.org/feeds/all.atom.xml" rel="self"></link><id>http://www.mos6581.org/</id><updated>2014-02-23T00:00:00+01:00</updated><entry><title>Exploring an alternative to git-subtree</title><link href="http://www.mos6581.org/git_subtree_alternative" rel="alternate"></link><updated>2014-02-23T00:00:00+01:00</updated><author><name>Brecht Machiels</name></author><id>tag:www.mos6581.org,2014-02-23:git_subtree_alternative</id><summary type="html">
&lt;p&gt;When you want to include external code in your git repository, for example a
third-party library or code shared with another team, there are two popular
options: git-submodule and git-subtree. Unfortunately both suffer from
some problems and this led me to start thinking about an alternative way to
handle external repositories.&lt;/p&gt;
&lt;p&gt;I will first summarize how git-submodule and git-subtree work and discuss their
drawbacks. I will then introduce an alternative to these, "git-subrepo" and
present a (partial) proof-of-concept implementation. In the following, we assume
a single submodule/subtree/subrepo.&lt;/p&gt;
&lt;div class="section" id="git-submodule"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;git-submodule&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Submodules are the officially supported way of including external repositories;
git-submodule is included with every git installation. A submodule is
basically a pointer to a commit of an external git repository. This model works
well when you want to include a third-party library in your project that
&lt;em&gt;only occasionally needs to be updated&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;On the other hand, if you use a submodule for a tightly-coupled library to
which you will often be making changes, you will find that submodules are not
the answer. In this use case, you will simultaneously be making changes to your
top-level project and the library. When the time has come to commit these
changes, you first need to commit your changes in the submodule, then do the
same in your top-level project. Oh, and make sure you push the changes to the
submodule before committing and pushing the top-level changes or other people
will run into trouble when pulling in your top-level commit. Things get even
more exciting when you want to push that submodule commit afterwards to fix
things, only to find out that someone sneaked in a commit in the meantime! Now
you’ll have to create a new commit on the top-level project to point it to your
rebased commit, hah! In short: too much of a hassle and far too easy to make a mess.&lt;/p&gt;
&lt;p&gt;If that’s not enough to convince you, you should try branching with this setup.
You’ll have to manually branch (and later merge) each of your submodules when
you create a new branch.&lt;/p&gt;
&lt;p&gt;In the past, I have worked with a git repository containing a dozen
tightly-coupled submodules for code-sharing with other teams. Needless to say,
it didn’t take very long to realize that submodules are not suited for that use case.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="git-subtree"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;git-subtree&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/apenwarr/git-subtree/blob/master/git-subtree.txt"&gt;git-subtree&lt;/a&gt; avoids most of the problems submodules suffer from. During everyday
work, you won’t have to worry about a thing, as git-subtree is only needed when
interfacing with external repositories. So, most of the time you are working
with a single repository; the library is simply included in your repository
as a subdirectory. That means that branching is also transparent. This is
infinitely more comfortable than mucking about with submodules.&lt;/p&gt;
&lt;p&gt;At some point you can choose to have git-subtree extract the changes to your
library from the commit history. This will create a new branch with a commit for
each commit of the top-level project that includes changes to the library. The
root directory of this new branch is equal to the subdirectory where the library
resides. The new branch can then be pushed to the library’s remote, where it can
be merged with other branches. After all, that’s the point of having a submodule
or a subtree.&lt;/p&gt;
&lt;p&gt;Unfortunately, splitting out these subtree changes &lt;a class="reference external" href="http://stackoverflow.com/questions/16134975/reduce-increasing-time-to-push-a-subtree"&gt;can take a long time&lt;/a&gt;. And
unless you use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--rejoin&lt;/span&gt;&lt;/tt&gt; option, git-subtree needs to perform this splitting
over and over for all commits in your history on each split. The &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--rejoin&lt;/span&gt;&lt;/tt&gt; option
merges the new subtree branch back into the main project’s branch, duplicating
the existing commits. While this raises no technical worries, your history will
be complicated unnecessarily.&lt;/p&gt;
&lt;!-- New commits on fetched from the remote can also be merged back into the main
project's branch (using the subtree merge strategy, hence the name git-subtree). --&gt;
&lt;/div&gt;
&lt;div class="section" id="the-alternative-git-subrepo"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id9"&gt;The alternative, git-subrepo&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It would be better if changes were split between the main project and the
library at commit time, basically yielding two actual commits. The main
project commit would then simply (subtree-)merge in the
library’s commit. This way the library’s commit can be used as-is for pushing to
the library remote. Let’s illustrate this with a figure.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="" src="images/subrepo_commit.png"/&gt;
&lt;p class="caption"&gt;Subrepo commit&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;em&gt;master&lt;/em&gt; branch (left) holds the commits of the main project and the &lt;em&gt;library&lt;/em&gt;
branch (right) holds the commits of the library (shown in red). Let’s refer to
the latter as the &lt;em&gt;subrepo branch&lt;/em&gt; and &lt;em&gt;subrepo commits&lt;/em&gt; for lack of better
terms. The "logical commits" C and E contain no changes to the library; only a
single commit is created. Commits A, B and D do make changes to the library, so
two actual commits are created for each logical commit.&lt;/p&gt;
&lt;p&gt;Commit A is the commit that introduces the subdirectory where the library
resides, so this yields the first commit of the library branch. As with
git-subtree, an existing library branch could be subtree-merged into the master
branch first, in which case we would build on that history.&lt;/p&gt;
&lt;p&gt;Note that the library branch is completely independent of the master branch, so
it can be pushed to the library’s remote at any point in time. There is no need
for splitting or rejoining as is the case with git-subtree.&lt;/p&gt;
&lt;p&gt;Aside from splitting up commits, we also need to take special care when merging
and rebasing. The figure below illustrates how &lt;strong&gt;merges&lt;/strong&gt; should be handled. The
branched-off subrepo commits first need to be merged into the &lt;em&gt;library&lt;/em&gt; branch.
As with the commit-splitting above, the resulting subrepo merge-commit is
referenced as a parent of the merge-commit on the main &lt;em&gt;master&lt;/em&gt; branch.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="" src="images/subrepo_merge.png"/&gt;
&lt;p class="caption"&gt;Subrepo merge&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Rebasing&lt;/strong&gt; is fairly straight-forward. A subrepo commit is rebased onto the
&lt;em&gt;library&lt;/em&gt; subrepo branch. The corresponding main-line commit is rebased
onto the &lt;em&gt;master&lt;/em&gt; branch and references the rebased subrepo commit as a parent.&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="" src="images/subrepo_rebase.png"/&gt;
&lt;p class="caption"&gt;Subrepo rebase&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="proof-of-concept"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id10"&gt;Proof of concept&lt;/a&gt;&lt;/h3&gt;
&lt;!-- I have to say that I was pleased to find that the
content-addressable filesystem that lies at the core of git
has a very simple and elegant design. I was not prepared for that, after
witnessing the small disaster that the git command line interface is. --&gt;
&lt;p&gt;I hacked together &lt;a class="reference external" href="https://github.com/brechtm/git-subrepo"&gt;post-commit and post-merge hook scripts&lt;/a&gt; to implement some
of the functionality discussed above. These hooks expect you specify the subrepo
directories in a &lt;tt class="docutils literal"&gt;.gitsubrepos&lt;/tt&gt; file in the root of your repository. Each
subrepo directory should be specified on its own line.&lt;/p&gt;
&lt;p&gt;The post-commit hook should work fairly well. Since this is a &lt;em&gt;post&lt;/em&gt;-commit
script, you simply perform your commit as usual. The hook script will create the
subrepo commits for each of the subrepos with changes, cloning the commit
metadata (timestamp, author) from your commit. A new main-line commit will also
be created that references the subrepo commit as a parent. After finishing, git
will still report the &lt;span class="caps"&gt;SHA&lt;/span&gt;-1 of the original commit though, so don’t let that
fool you.&lt;/p&gt;
&lt;p&gt;Note that branching is handled transparently. The parent for the split-off
subrepo commit is found by walking the history down to the last commit that
merges in a subrepo commit. Branches have no influence on this.&lt;/p&gt;
&lt;p&gt;During merging, you handle conflicts as usual, after which the post-merge hook
will try to create merge commits for each of the subrepos. In its current state,
the hook will produce some unexpected results in some situations though.&lt;/p&gt;
&lt;p&gt;I have not yet attempted to write a hook to handle rebases and amend-commits.
This will almost require a &lt;a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/githooks.html#_post_rewrite"&gt;post-rewrite&lt;/a&gt; hook.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="probl-err-challenges"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;Probl… err, challenges&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Assuming it is possible to write a post-rewrite script to handle rebasing and
amend-commits, I believe subrepos could be a better alternative to git-subtree.
Unfortunately, I also see some problems with this solution.&lt;/p&gt;
&lt;p&gt;First, I don’t think hooks are the correct way to implement subrepos, but I
have no idea how to go about it otherwise. I’m not aware of any other git
features that allow plugging into the commit, merge and rebase processes. The
alternative is to require the user to use different commands for performing
these operations, which is something I want to avoid.&lt;/p&gt;
&lt;p&gt;Second, the way the history with subrepo commits is displayed in git-log and
gitk (and other graphical git front-ends) leaves something to be desired. For
instance, if you commit changes to N subrepos you will end up with N+1 commits,
which clutters the commit history even for small N. Take a look at this &lt;a class="reference external" href="https://github.com/brechtm/git-subrepo-test"&gt;sample
repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Also, each commit with subrepo changes will be displayed as a merge commit. Gitk
does not show changes in the subrepo if this commit only merges in a single
subrepo commit. When multiple subrepo commits are merged in, gitk does show the
changes, but as a complicated N-way merge diff.&lt;/p&gt;
&lt;p&gt;Ideally, gitk should be made aware of subrepos; it should group all subrepo
commits together with the main commit and display it as a single entry. I feel
this is a fair price to pay for proper, first-class subrepositories support.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="random-ideas"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;Random Ideas&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For future reference, here are some ideas for git-subrepo.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;When a commit includes changes to one or more subrepos, the commit message
template should include sections for each subrepo. This way the user can
specify the commit message for each of the subrepo commits. This is much
better than the current behaviour where the same commit message is used for
the main commit and all subrepo commits. This will require a
&lt;a class="reference external" href="https://www.kernel.org/pub/software/scm/git/docs/githooks.html#_prepare_commit_msg"&gt;prepare-commit-msg&lt;/a&gt; hook.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;git-subrepo should create branches to track the subrepos. They could have the
following format:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
subrepo/&amp;lt;subrepo name&amp;gt;/&amp;lt;HEAD branch name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;This allows the user to easily inspect the history of subrepos separately.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="git"></category></entry><entry><title>Introducing RinohType</title><link href="http://www.mos6581.org/introducing-rinohtype" rel="alternate"></link><updated>2013-11-03T00:00:00+01:00</updated><author><name>Brecht Machiels</name></author><id>tag:www.mos6581.org,2013-11-03:introducing-rinohtype</id><summary type="html">
&lt;p&gt;I originally planned to release RinohType into wild only after I had finished a full review, refactoring and documenting of the code. I also wanted to write some &lt;span class="caps"&gt;API&lt;/span&gt; documentation and a small tutorial, all in the spirit of making a good first impression. Turns out all this takes a huge amount of time! So I’ve decided to dump the code in its current state onto GitHub, write a blog article about it and await some valuable feedback while I resume my refactoring and documenting chore.&lt;/p&gt;
&lt;p&gt;If you decide to play around with the code, please bear in mind that this is just a preview; your experience might not be as smooth as I intend it to be eventually.&lt;/p&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;Motivation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Somewhere back in 2009, I was using &lt;a class="reference external" href="http://en.wikipedia.org/wiki/LaTeX"&gt;LaTeX&lt;/a&gt; to write a paper on some of my &lt;a class="reference external" href="{filename}pages/thesis.rst"&gt;PhD research&lt;/a&gt;. I had used LaTeX before for a number of lab reports and two master’s theses, so I was already experienced with it. While I find working with LaTeX is generally a smooth experience, I did encounter some annoyances over the years. The particular annoyance of the day was figure placement. Where LaTeX’s automatic figure placement is pretty good in longer texts, I find it extremely frustrating when writing a short paper. For these papers, I basically want to place my figures manually, exactly where I want them (figure 2 goes in the top of the left column on page 2, for example). However, this doesn’t seem to be an option with LaTeX, so I ended up moving my &lt;tt class="docutils literal"&gt;\includegraphics&lt;/tt&gt; directive around in the LaTeX source document in a trial-and-error fashion to have the figure eventually appear where I wanted it to be. Basically, this meant moving all my &lt;tt class="docutils literal"&gt;\includegraphics&lt;/tt&gt; directives to a location far from near the text where it would end up in the rendered document. After a good hour of messing around with this and &lt;a class="reference external" href="http://www.ntg.nl/pipermail/ntg-context/2008/037150.html"&gt;exploring&lt;/a&gt;  two alternatives to LaTeX (&lt;a class="reference external" href="http://en.wikipedia.org/wiki/Lout_(software)"&gt;Lout&lt;/a&gt; and &lt;a class="reference external" href="http://en.wikipedia.org/wiki/ConTeXt"&gt;ConTeXt&lt;/a&gt;), I said to myself, &lt;em&gt;Enough! I’m writing my own document processor!&lt;/em&gt; And so I set out to build the definitive replacement for LaTeX.&lt;/p&gt;
&lt;p&gt;It is worth pointing out the other gripes I have with (La)TeX at this point. I will probably regret this later (I have the impression TeXies can be quite fanatical), but here we go:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;TeX is not transparent. It is a huge, complex system. To make things worse, there are a number of different TeX distributions, each organizing things in a slightly different way. With hundreds of megabytes and seemingly millions of files for a typical TeX installation, I have no idea what is going on when TeX processes a document. &lt;a class="reference external" href="http://www.ctan.org/pkg/kpathsea"&gt;kpathsea&lt;/a&gt; is a testament to a part of this complexity.&lt;/li&gt;
&lt;li&gt;The arcane TeX macro language is not accessible to a broad audience. I believe this is why most LaTeX-generated documents you come across have exactly the same (retro) look; very few people are capable of creating new document styles.&lt;/li&gt;
&lt;li&gt;TeX is not very modern. Yes, even today it still is a very impressive piece of software. However, next to being built upon some weird macro language of old, it predates a lot of modern technologies (Unicode, standard font file formats, Postscript and &lt;span class="caps"&gt;PDF&lt;/span&gt;), so these things had to be hacked into it. While I understand you generally shouldn’t rewrite software from scratch, maybe TeX should be one of the few exceptions to this rule?&lt;/li&gt;
&lt;li&gt;TeX’s warnings/errors are often very cryptic. It can sometimes take a long time to figure out what’s wrong.&lt;/li&gt;
&lt;li&gt;(La)TeX has an incredible amount of extension packages available. There’s probably a package for pretty much &lt;a class="reference external" href="http://tex.stackexchange.com/questions/67656/are-there-other-fun-packages-like-the-coffee-stains-package"&gt;anything you might ever need&lt;/a&gt;. But why do I even need to mess around with all these extension packages when all I’m doing is writing a simple article? Doesn’t this mean that LaTeX should include at least some of the most commonly used packages by default?&lt;/li&gt;
&lt;li&gt;This might largely be a solved problem by now, but I remember often running into input and font encoding issues with LaTeX in the past.&lt;/li&gt;
&lt;li&gt;There is no strict separation of content and style. This is mostly an issue for publishers that want to ensure a consistent style across articles in a journal. With LaTeX, academic authors can always reduce the margins or change the interline spacing to be able to squeeze in more half-truths.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wow, this all sounds very negative. I should mention that RinohType was in a large part also inspired by (La)TeX in a positive way; the latter gets a lot of things right indeed. However, I believe we can do better than TeX. Not so much in the typesetting quality, but in the ease-of-use.&lt;/p&gt;
&lt;p&gt;For me, the obvious programming language to choose for this little project was Python, as it is probably the most accessible programming language and generally fun to program in (ok, that’s subjective). I imagined Python’s powerful &lt;span class="caps"&gt;OO&lt;/span&gt; could be employed to define document styles that could easily be inherited from. Initially, I also planned on the source document being Python source files. While technically possible, I am now convinced that Python’s syntax is not suited for this purpose.&lt;/p&gt;
&lt;p&gt;My goals in developing RinohType are mostly inspired by (La)TeX’s shortcomings and common sense:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;RinohType should have a simple, transparent design and depend on as few external libraries as possible. This helps to keep installation and usage simple.&lt;/li&gt;
&lt;li&gt;It should be easy to define custom document layouts and visual styles.&lt;/li&gt;
&lt;li&gt;RinohType should accept Unicode input (only!).&lt;/li&gt;
&lt;li&gt;There should be built-in support for images and floats.&lt;/li&gt;
&lt;li&gt;It should be able to perform high-quality typesetting, supporting kerning, ligatures and hyphenation at the least.&lt;/li&gt;
&lt;li&gt;It should be able to typeset complex mathematical formulae.&lt;/li&gt;
&lt;li&gt;It should support modern font technologies (OpenType) and output to &lt;span class="caps"&gt;PDF&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Naturally, it should support obvious features such as cross-references, page numbering, footnotes, table of contents and index generation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;Current Status&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Because of the Unicode requirement, I opted to skip Python 2 and go with Python 3 which uses Unicode for all text strings. This avoids all problems associated with input encoding and simplifies text handling internally.&lt;/p&gt;
&lt;p&gt;At the time of writing, RinohType implements:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A simple, but powerful page layout engine, allowing for page headers/footers, columns and floats.&lt;/li&gt;
&lt;li&gt;Typesetting is already quite capable, supporting hyphenation, sub/superscripts, kerning, ligatures, text justification (left, right, justified) and alignment to tab stops.&lt;/li&gt;
&lt;li&gt;A hierarchical styles system, for both paragraphs and other objects such as figures and tables.&lt;/li&gt;
&lt;li&gt;Nestable inline text styling.&lt;/li&gt;
&lt;li&gt;Support for Type1, TrueType and OpenType (both the TrueType and &lt;span class="caps"&gt;CFF&lt;/span&gt;/Postscript/Type1 variants) fonts.&lt;/li&gt;
&lt;li&gt;A simple &lt;span class="caps"&gt;PDF&lt;/span&gt; backend. Other backends can be easily added.&lt;/li&gt;
&lt;li&gt;Numbered, unnumbered and definition lists.&lt;/li&gt;
&lt;li&gt;Figures (input as &lt;span class="caps"&gt;PDF&lt;/span&gt; files) and basic tables (with row/column spanning), with automatically numbered captions.&lt;/li&gt;
&lt;li&gt;Cross-references, automatic page numbering and footnotes.&lt;/li&gt;
&lt;li&gt;Automatically generated table of contents.&lt;/li&gt;
&lt;li&gt;With the help of &lt;a class="reference external" href="https://pypi.python.org/pypi/citeproc-py"&gt;citeproc-py&lt;/a&gt;, support for citing references from a BibTeX database and generating a bibliography.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The one major omission from this list is formula rendering. I did try using the TeX formula renderer from matplotlib (the &lt;tt class="docutils literal"&gt;mathtext&lt;/tt&gt; module) and &lt;a class="reference external" href="http://sourceforge.net/projects/svgmath/"&gt;SVGMath&lt;/a&gt;, but with unsatisfactory results. I’ve decided to write math rendering from scratch once the core of RinohType (everything listed above) is working properly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="example-documents-and-input-formats"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;Example Documents and Input Formats&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;EDIT&lt;/span&gt;&lt;/strong&gt; Some &lt;span class="caps"&gt;PDF&lt;/span&gt; viewers (Firefox’s pdf.js, Evince, ePDFViewer) seem to have a problem with the &lt;span class="caps"&gt;CFF&lt;/span&gt; OpenType fonts embedded in the sample &lt;span class="caps"&gt;PDF&lt;/span&gt; files below. I still need to determine if this is a bug in these viewers or in RinohType (see &lt;a class="reference external" href="https://github.com/brechtm/rinohtype/issues/2"&gt;issue 2&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;After abandoning the idea to use Python source files as the input format, I opted to go with &lt;span class="caps"&gt;XML&lt;/span&gt;, since it’s a very common format and, more importantly, allows for validation using &lt;span class="caps"&gt;XML&lt;/span&gt; schemas. The &lt;a class="reference external" href="https://github.com/brechtm/rinohtype/tree/master/examples/rfic2009"&gt;&lt;span class="caps"&gt;RFIC&lt;/span&gt; example&lt;/a&gt; in the RinohType repository makes use of a custom &lt;span class="caps"&gt;XML&lt;/span&gt; input format, as defined in &lt;tt class="docutils literal"&gt;rfic.rnc&lt;/tt&gt; (&lt;a class="reference external" href="http://relaxng.org/compact-tutorial-20030326.html"&gt;&lt;span class="caps"&gt;RELAX&lt;/span&gt; &lt;span class="caps"&gt;NG&lt;/span&gt; Compact&lt;/a&gt;). This example shows off most of RinoType’s capabilities. Download the &lt;a class="reference external" href="/files/intro_template.pdf"&gt;generated &lt;span class="caps"&gt;PDF&lt;/span&gt;&lt;/a&gt; to see the output.&lt;/p&gt;
&lt;p&gt;Guided by the &lt;span class="caps"&gt;RFIC&lt;/span&gt; example, it should be fairly straightforward (but still a lot of work) to write a DocBook frontend for RinohType. &lt;span class="caps"&gt;XML&lt;/span&gt; is also a great intermediate format, useful when to-&lt;span class="caps"&gt;XML&lt;/span&gt; converters for other input formats are available.&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;XML&lt;/span&gt; is unfortunately not the best format for hand editing. One of the advantages of TeX source files is that they are easy to write and read (the content parts anyway). Luckily, Python’s "native"
&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;reStructuredText&lt;/a&gt; is a great markup syntax that is easy to write and read. Additionally, it is extensible, which makes it pretty much the perfect input format for RinohType (I haven’t thought about how to verify rST input yet, though). The &lt;a class="reference external" href="https://github.com/brechtm/rinohtype/tree/master/examples/restructuredtext"&gt;rST example&lt;/a&gt; attempts to typeset the &lt;a class="reference external" href="http://docutils.sourceforge.net/docs/user/rst/quickstart.html"&gt;ReStructuredText Primer&lt;/a&gt;. Here is the &lt;a class="reference external" href="/files/intro_rst.pdf"&gt;output&lt;/a&gt;. The rST parser contained in &lt;tt class="docutils literal"&gt;rst.py&lt;/tt&gt; will eventually be moved into the core of RinohType as a frontend.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="evaluation"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;Evaluation&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unsurprisingly, even after four years into its development, RinohType still does not provide an option for absolute figure placement, the missing LaTeX feature that started this journey. Of course, a lot of other things needed to be put in place before this could be addressed. While I could implement this feature at this point, there are more pressing things to address.&lt;/p&gt;
&lt;p&gt;I’m pretty happy with the result so far and I’m especially proud of the simplicity and compactness of the code. The &lt;tt class="docutils literal"&gt;rinoh&lt;/tt&gt; Python package counts less than 6500 lines of code (excluding comments/docstrings and empty lines). This includes both the &lt;span class="caps"&gt;PDF&lt;/span&gt; backend (1700 lines) and the font parsers (1750 lines), so the core of RinohType comprises only about 3000 lines of code! I think this is in a large part made possible due to the expressive power of Python. Though the fact that I was constantly refactoring must have also been an important factor.&lt;/p&gt;
&lt;p&gt;One aspect that I’m not so enthusiastic about is RinohType’s performance. On my modest &lt;a class="reference external" href="http://ark.intel.com/products/40738/Intel-Celeron-Processor-T3000-1M-Cache-1_80-GHz-800-MHz-FSB"&gt;Celeron T3000 1.8 GHz&lt;/a&gt; laptop, the average rendering time for a page in the &lt;span class="caps"&gt;RFIC&lt;/span&gt; example is a disappointing 0.8 seconds. For small documents, this is unlikely to be a problem, but for books it’s problematic. RinohType should become &lt;em&gt;at least&lt;/em&gt; a factor of ten faster. I’ve already introduced some optimizations such as &lt;a class="reference external" href="http://stackoverflow.com/questions/1988804/what-is-memoization-and-how-can-i-use-it-in-python"&gt;memoization&lt;/a&gt; and using generators instead of lists, but it is clearly not cutting it. Looking for an easy solution, I’ve done some quick tests with PyPy3k (rendering the &lt;span class="caps"&gt;RFIC&lt;/span&gt; example over and over in a loop), but these were rather disappointing; rendering speed was about five times &lt;em&gt;slower&lt;/em&gt; compared to CPython. With Cython, I’m not sure what part of the code to enhance with type declarations, as there is no obvious number crunching going on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="planned-work"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;Planned Work&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I first want to finish refactoring and documenting the remaining parts of the code. When this is done, performance tweaking will probably be near the top of my to-do list. Once the current functionality is more or less stable, I’d like to tackle maths typesetting. I’m secretly hoping Microsoft’s mathematical OpenType layout extensions can help me get good results for at least a &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Category:Mathematical_OpenType_typefaces"&gt;small number of fonts&lt;/a&gt; with minimal effort.&lt;/p&gt;
&lt;p&gt;Some other features that I have been thinking of, in order of likeliness to actually make it into RinohType in the foreseeable future:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Manual figure placement!&lt;/li&gt;
&lt;li&gt;Provide a number of standard document/page/font styles&lt;/li&gt;
&lt;li&gt;Fake small capitals for fonts that do not provide any&lt;/li&gt;
&lt;li&gt;Enhance the &lt;span class="caps"&gt;PDF&lt;/span&gt; backend with support for colors, hyperlinks, bookmarks, etc.&lt;/li&gt;
&lt;li&gt;Provide a RinohType output backend for &lt;a class="reference external" href="http://sphinx-doc.org"&gt;Sphinx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Include font definitions for freely available fonts (automatically downloaded when referenced)&lt;/li&gt;
&lt;li&gt;Advanced typesetting features such as Knuth-Plass line breaking and &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Microtypography"&gt;microtypography&lt;/a&gt; as in PDFTeX (once performance is up to standards)&lt;/li&gt;
&lt;li&gt;DocBook frontend&lt;/li&gt;
&lt;li&gt;Support for non-Western languages; support &lt;span class="caps"&gt;RTL&lt;/span&gt; text and related OpenType extensions&lt;/li&gt;
&lt;li&gt;Non-rectangular paragraphs&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="for-the-brave-dependencies"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;For the Brave / Dependencies&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;You can try out RinohType by cloning &lt;a class="reference external" href="https://github.com/brechtm/rinohtype"&gt;the repository&lt;/a&gt;, adding the top-level directory to your &lt;tt class="docutils literal"&gt;PYTHON_PATH&lt;/tt&gt; and running the examples.&lt;/p&gt;
&lt;p&gt;For the &lt;span class="caps"&gt;RFIC&lt;/span&gt; example, you will need &lt;a class="reference external" href="https://pypi.python.org/pypi/citeproc-py"&gt;citeproc-py&lt;/a&gt;. If you want to validate the &lt;span class="caps"&gt;XML&lt;/span&gt; input, you will also need &lt;a class="reference external" href="http://lxml.de"&gt;lxml&lt;/a&gt;. For the reStructuredText example, you need &lt;a class="reference external" href="https://pypi.python.org/pypi/docutils"&gt;docutils&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While it should be obvious how to adjust the text styles in the examples, it is not equally obvious how page layout is defined in the &lt;span class="caps"&gt;RFIC&lt;/span&gt; example. Also, an introduction on how the parsed input data (&lt;span class="caps"&gt;XML&lt;/span&gt; or rST) is processed might be useful if you want to define another &lt;span class="caps"&gt;XML&lt;/span&gt; input schema or extend the reStructuredText frontend. For this reason, I plan on following up on this article with a short tutorial covering these topics before I start writing official documentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-license"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;The License&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this originally started out as just another one of my programming projects, I am investigating the possibility to sell licenses for commercial use, as this could ensure that RinohType is actively developed in the future. I have therefor released RinohType under the Affero &lt;span class="caps"&gt;GPL&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The Affero &lt;span class="caps"&gt;GPL&lt;/span&gt; ensures that RinohType is free for use in open source projects. I am aware that the viral nature of the &lt;span class="caps"&gt;GPL&lt;/span&gt; makes it impossible for non-&lt;span class="caps"&gt;GPL&lt;/span&gt; projects to depend on RinohType, though. Unfortunately, it is this same viral nature that makes it possible to sell commercial-use licenses (a non-intentional side-effect of the copyleft?). Perhaps it is possible to employ a &lt;span class="caps"&gt;BSD&lt;/span&gt;-like license customized to prohibit commercial use? I have not yet found any examples of such a setup, but I will look into this.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="discussion"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Discussion&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;See comments on &lt;a class="reference external" href="https://news.ycombinator.com/item?id=6668551"&gt;Hacker News&lt;/a&gt; and &lt;a class="reference external" href="http://www.reddit.com/r/Python/comments/1pw20k/introducing_rinohtype_the_python_document/"&gt;Reddit&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python"></category></entry></feed>